# -*- coding: utf-8 -*-
"""spx_alignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17GH8laeOjz3BEDKIog0SH2aA7S34BYfW
"""

import yfinance as yf
import pandas as pd
from datetime import datetime, timedelta
import requests
import io
import time

# 텔레그램 봇 설정
TELEGRAM_TOKEN = '7734786706:AAEhu2w_KUtahzp14bBRlyu8WEUvZn6sa7M'
TELEGRAM_CHAT_ID = '309362453'

def send_telegram_message(message):
    try:
        # 메시지 길이 제한 (4096자 초과 시 분할)
        MAX_LENGTH = 4096
        if len(message) > MAX_LENGTH:
            for i in range(0, len(message), MAX_LENGTH):
                chunk = message[i:i + MAX_LENGTH]
                payload = {'chat_id': TELEGRAM_CHAT_ID, 'text': chunk}
                response = requests.post(f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage", json=payload)
                response.raise_for_status()
                time.sleep(1)  # API 제한 방지
        else:
            payload = {'chat_id': TELEGRAM_CHAT_ID, 'text': message}
            response = requests.post(f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage", json=payload)
            response.raise_for_status()
        print("텔레그램 메시지 전송 완료")
    except Exception as e:
        print(f"텔레그램 전송 오류: {e}")

# S&P 500 티커 및 섹터 리스트 가져오기
def get_sp500_tickers():
    try:
        url = 'https://raw.githubusercontent.com/datasets/s-and-p-500-companies/main/data/constituents.csv'
        headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'}
        response = requests.get(url, headers=headers)
        response.raise_for_status()
        df_tickers = pd.read_csv(io.StringIO(response.text))
        df_tickers['Symbol'] = df_tickers['Symbol'].str.replace('.', '-', regex=False)
        print(f"S&P 500 티커 {len(df_tickers)}개 로드 완료.")
        return df_tickers[['Symbol', 'GICS Sector']].to_dict('records')
    except Exception as e:
        print(f"티커 로드 오류: {e}")
        return [
            {'Symbol': 'AAPL', 'GICS Sector': 'Information Technology'},
            {'Symbol': 'MSFT', 'GICS Sector': 'Information Technology'},
            {'Symbol': 'AMZN', 'GICS Sector': 'Consumer Discretionary'},
            {'Symbol': 'GOOGL', 'GICS Sector': 'Communication Services'},
            {'Symbol': 'META', 'GICS Sector': 'Communication Services'},
            {'Symbol': 'TSLA', 'GICS Sector': 'Consumer Discretionary'},
            {'Symbol': 'NVDA', 'GICS Sector': 'Information Technology'},
            {'Symbol': 'JPM', 'GICS Sector': 'Financials'},
            {'Symbol': 'HD', 'GICS Sector': 'Consumer Discretionary'},
            {'Symbol': 'PFE', 'GICS Sector': 'Health Care'},
            {'Symbol': 'CVX', 'GICS Sector': 'Energy'},
            {'Symbol': 'XOM', 'GICS Sector': 'Energy'}
        ]

# 시총 상위 100종목 추출
def get_top_100_by_market_cap(tickers):
    market_caps = []
    for item in tickers:
        symbol = item['Symbol']
        try:
            ticker = yf.Ticker(symbol)
            market_cap = ticker.info.get('marketCap', 0) / 1e8  # 억 달러
            market_caps.append((symbol, market_cap, item['GICS Sector']))
            time.sleep(0.1)
        except Exception as e:
            print(f"{symbol} 시총 데이터 오류: {e}")
    market_caps = sorted(market_caps, key=lambda x: x[1], reverse=True)[:100]
    return market_caps

# AAPL 기준 최신 거래일
def get_latest_trading_day():
    try:
        data = yf.download('AAPL', start=(datetime.now() - timedelta(days=10)).strftime('%Y-%m-%d'), end=datetime.now().strftime('%Y-%m-%d'), progress=False)
        if data.empty:
            raise ValueError("AAPL 데이터 없음")
        return data.index[-1].strftime('%Y-%m-%d')
    except Exception as e:
        print(f"AAPL 최신 거래일 오류: {e}")
        return (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')

# 티커 및 섹터 리스트
sp500 = get_sp500_tickers()
total_tickers = len(sp500)

# 날짜 설정
end_date = get_latest_trading_day()  # 2025-10-07
start_date = (datetime.strptime(end_date, '%Y-%m-%d') - timedelta(days=100)).strftime('%Y-%m-%d')

# 결과 리스트
정배열 = []
역배열 = []
신규_정배열 = []  # (티커, 변화율)
정배열_이탈 = []  # (티커, 변화율)
top_100_정배열 = []
top_100_역배열 = []
top_100_신규_정배열 = []
top_100_정배열_이탈 = []
sector_data = {sector: {'정배열': [], '역배열': [], '신규_정배열': [], '정배열_이탈': [], 'total': 0} for sector in set(item['GICS Sector'] for item in sp500)}

# 섹터별 종목 수 계산
for item in sp500:
    sector_data[item['GICS Sector']]['total'] += 1

# 시총 상위 100종목
top_100 = get_top_100_by_market_cap(sp500)
top_100_tickers = [x[0] for x in top_100]

for item in sp500:
    symbol = item['Symbol']
    sector = item['GICS Sector']
    try:
        data = yf.download(symbol, start=start_date, end=end_date, progress=False, auto_adjust=True)
        if data.empty or 'Close' not in data.columns:
            print(f"{symbol} 데이터 없음 또는 'Close' 열 누락")
            continue
        data = data[['Close']].copy().sort_index(ascending=True).dropna()

        if len(data) < 50:
            print(f"{symbol} 데이터 부족 ({len(data)} rows)")
            continue

        # EMA 계산
        data['10ema'] = data['Close'].ewm(span=10, adjust=False).mean()
        data['20ema'] = data['Close'].ewm(span=20, adjust=False).mean()
        data['50ema'] = data['Close'].ewm(span=50, adjust=False).mean()

        # 정배열 및 역배열
        data['정배열'] = (data['10ema'] > data['20ema']) & (data['20ema'] > data['50ema'])
        data['역배열'] = (data['10ema'] < data['20ema']) & (data['20ema'] < data['50ema'])

        # 최신 행 (T일)
        if data['정배열'].iloc[-1]:
            정배열.append(symbol)
            if symbol in top_100_tickers:
                top_100_정배열.append(symbol)
            sector_data[sector]['정배열'].append(symbol)
        if data['역배열'].iloc[-1]:
            역배열.append(symbol)
            if symbol in top_100_tickers:
                top_100_역배열.append(symbol)
            sector_data[sector]['역배열'].append(symbol)

        # 신규 정배열 및 정배열 이탈
        if len(data) >= 6:
            prev_bullish = data['정배열'].shift(5).fillna(False).iloc[-1]
            curr_bullish = data['정배열'].iloc[-1]
            try:
                close_t = float(data['Close'].iloc[-1])
                close_t_minus_1 = float(data['Close'].iloc[-2]) if len(data) >= 2 else close_t
                close_t_minus_5 = float(data['Close'].iloc[-6])
                ema10_t = float(data['10ema'].iloc[-1])
                ema10_t_minus_1 = float(data['10ema'].iloc[-2]) if len(data) >= 2 else ema10_t
                price_change = ((close_t - close_t_minus_5) / close_t_minus_5) * 100
            except Exception as e:
                print(f"{symbol} 변화율 계산 오류: {e}")
                price_change = 0.0

            if not prev_bullish and curr_bullish:
                신규_정배열.append((symbol, price_change))
                if symbol in top_100_tickers:
                    top_100_신규_정배열.append((symbol, price_change))
                sector_data[sector]['신규_정배열'].append((symbol, price_change))
            if prev_bullish and not curr_bullish and close_t < ema10_t and close_t_minus_1 < ema10_t_minus_1:
                정배열_이탈.append((symbol, price_change))
                if symbol in top_100_tickers:
                    top_100_정배열_이탈.append((symbol, price_change))
                sector_data[sector]['정배열_이탈'].append((symbol, price_change))

        time.sleep(0.5)

    except Exception as e:
        print(f"{symbol} 처리 오류: {e}")
        continue

# 변화율 기준 정렬
신규_정배열 = sorted(신규_정배열, key=lambda x: x[1], reverse=True)
정배열_이탈 = sorted(정배열_이탈, key=lambda x: x[1])
top_100_신규_정배열 = sorted(top_100_신규_정배열, key=lambda x: x[1], reverse=True)
top_100_정배열_이탈 = sorted(top_100_정배열_이탈, key=lambda x: x[1])
for sector in sector_data:
    sector_data[sector]['신규_정배열'] = sorted(sector_data[sector]['신규_정배열'], key=lambda x: x[1], reverse=True)
    sector_data[sector]['정배열_이탈'] = sorted(sector_data[sector]['정배열_이탈'], key=lambda x: x[1])

# 비율 계산
정배열_비율 = len(정배열) / total_tickers * 100 if total_tickers > 0 else 0
정배열_역배열_비율 = len(정배열) / len(역배열) if len(역배열) > 0 else float('inf')
신규정배열_이탈_비율 = len(신규_정배열) / len(정배열_이탈) if len(정배열_이탈) > 0 else float('inf')
top_100_정배열_비율 = len(top_100_정배열) / len(top_100_tickers) * 100 if top_100_tickers else 0
top_100_정배열_역배열_비율 = len(top_100_정배열) / len(top_100_역배열) if len(top_100_역배열) > 0 else float('inf')
top_100_신규정배열_이탈_비율 = len(top_100_신규_정배열) / len(top_100_정배열_이탈) if len(top_100_정배열_이탈) > 0 else float('inf')
sector_stats = {}
for sector in sector_data:
    total = sector_data[sector]['total']
    sector_stats[sector] = {
        '정배열_비율': len(sector_data[sector]['정배열']) / total * 100 if total > 0 else 0,
        '신규정배열_이탈_비율': len(sector_data[sector]['신규_정배열']) / len(sector_data[sector]['정배열_이탈']) if len(sector_data[sector]['정배열_이탈']) > 0 else float('inf')
    }

# 출력 메시지 구성
message = f"📊 S&P 500 EMA(10,20,50) 요약 ({end_date}):\n"
message += f"전체 종목 ({total_tickers}개):\n"
message += f"- 정배열: {len(정배열)}개 ({정배열_비율:.2f}%)\n"
message += f"- 역배열: {len(역배열)}개\n"
message += f"- 신규 정배열: {len(신규_정배열)}개\n"
message += f"- 정배열 이탈: {len(정배열_이탈)}개\n"
message += f"- 정배열/역배열 비율: {정배열_역배열_비율:.2f}\n"
message += f"- 신규 정배열/이탈 비율: {신규정배열_이탈_비율:.2f}\n"
message += f"\n시총 상위 100종목:\n"
message += f"- 정배열: {len(top_100_정배열)}개 ({top_100_정배열_비율:.2f}%)\n"
message += f"- 신규 정배열/이탈 비율: {top_100_신규정배열_이탈_비율:.2f}\n"
message += f"\n섹터별 정배열 비율:\n"
for sector in sorted(sector_stats.keys()):
    message += f"- {sector}: {sector_stats[sector]['정배열_비율']:.2f}% (신규/이탈 비율: {sector_stats[sector]['신규정배열_이탈_비율']:.2f})\n"
message += f"\n📊 전체 상세 결과:\n"
message += f"정배열 종목 ({len(정배열)}개, 비율: {정배열_비율:.2f}%): {', '.join(정배열) if 정배열 else '없음'}\n"
message += f"역배열 종목 ({len(역배열)}개): {', '.join(역배열) if 역배열 else '없음'}\n"
message += f"신규 정배열 종목 ({len(신규_정배열)}개, 5일 전 대비 Close 변화율 높은 순):\n"
for symbol, change in 신규_정배열:
    message += f"  - {symbol}: {change:.2f}%\n"
message += f"정배열 이탈 종목 ({len(정배열_이탈)}개, 5일 전 대비 Close 변화율 낮은 순):\n"
for symbol, change in 정배열_이탈:
    message += f"  - {symbol}: {change:.2f}%\n"
message += f"\n📈 비율 통계:\n"
message += f"- 정배열 비율: {정배열_비율:.2f}% (정배열 {len(정배열)} / 전체 {total_tickers})\n"
message += f"- 정배열/역배열 비율: {정배열_역배열_비율:.2f} (정배열 {len(정배열)} / 역배열 {len(역배열)})\n"
message += f"- 신규 정배열/정배열 이탈 비율: {신규정배열_이탈_비율:.2f} (신규 정배열 {len(신규_정배열)} / 이탈 {len(정배열_이탈)})\n"
message += f"\n📊 시총 상위 100종목 EMA(10,20,50) Update:\n"
message += f"정배열 종목 ({len(top_100_정배열)}개, 비율: {top_100_정배열_비율:.2f}%): {', '.join(top_100_정배열) if top_100_정배열 else '없음'}\n"
message += f"역배열 종목 ({len(top_100_역배열)}개): {', '.join(top_100_역배열) if top_100_역배열 else '없음'}\n"
message += f"신규 정배열 종목 ({len(top_100_신규_정배열)}개, 5일 전 대비 Close 변화율 높은 순):\n"
for symbol, change in top_100_신규_정배열:
    message += f"  - {symbol}: {change:.2f}%\n"
message += f"정배열 이탈 종목 ({len(top_100_정배열_이탈)}개, 5일 전 대비 Close 변화율 낮은 순):\n"
for symbol, change in top_100_정배열_이탈:
    message += f"  - {symbol}: {change:.2f}%\n"
message += f"\n📈 시총 상위 100종목 비율 통계:\n"
message += f"- 정배열 비율: {top_100_정배열_비율:.2f}% (정배열 {len(top_100_정배열)} / 상위 100)\n"
message += f"- 정배열/역배열 비율: {top_100_정배열_역배열_비율:.2f} (정배열 {len(top_100_정배열)} / 역배열 {len(top_100_역배열)})\n"
message += f"- 신규 정배열/정배열 이탈 비율: {top_100_신규정배열_이탈_비율:.2f} (신규 정배열 {len(top_100_신규_정배열)} / 이탈 {len(top_100_정배열_이탈)})\n"
message += f"\n📊 섹터별 EMA(10,20,50) Update:\n"
for sector in sorted(sector_data.keys()):
    message += f"\n{sector}:\n"
    message += f"  - 정배열 ({len(sector_data[sector]['정배열'])}개): {', '.join(sector_data[sector]['정배열']) if sector_data[sector]['정배열'] else '없음'}\n"
    message += f"  - 역배열 ({len(sector_data[sector]['역배열'])}개): {', '.join(sector_data[sector]['역배열']) if sector_data[sector]['역배열'] else '없음'}\n"
    message += f"  - 신규 정배열 ({len(sector_data[sector]['신규_정배열'])}개, 변화율 높은 순):\n"
    for symbol, change in sector_data[sector]['신규_정배열']:
        message += f"    - {symbol}: {change:.2f}%\n"
    message += f"  - 정배열 이탈 ({len(sector_data[sector]['정배열_이탈'])}개, 변화율 낮은 순):\n"
    for symbol, change in sector_data[sector]['정배열_이탈']:
        message += f"    - {symbol}: {change:.2f}%\n"

# 텔레그램 메시지 전송
send_telegram_message(message)

# 콘솔 출력
print(message)