# -*- coding: utf-8 -*-
"""spx_alignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17GH8laeOjz3BEDKIog0SH2aA7S34BYfW
"""

import yfinance as yf
import pandas as pd
from datetime import datetime, timedelta
import requests
import io
import time
from zoneinfo import ZoneInfo

# 텔레그램 봇 설정
TELEGRAM_TOKEN = '7734786706:AAEhu2w_KUtahzp14bBRlyu8WEUvZn6sa7M'
TELEGRAM_CHAT_ID = '309362453'

def send_telegram_message(message):
    try:
        MAX_LENGTH = 4096
        if len(message) > MAX_LENGTH:
            for i in range(0, len(message), MAX_LENGTH):
                chunk = message[i:i + MAX_LENGTH]
                payload = {'chat_id': TELEGRAM_CHAT_ID, 'text': chunk}
                response = requests.post(f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage", json=payload)
                response.raise_for_status()
                time.sleep(1)
        else:
            payload = {'chat_id': TELEGRAM_CHAT_ID, 'text': message}
            response = requests.post(f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage", json=payload)
            response.raise_for_status()
        print("텔레그램 메시지 전송 완료")
    except Exception as e:
        print(f"텔레그램 전송 오류: {e}")

def get_sp500_tickers():
    try:
        url = 'https://raw.githubusercontent.com/datasets/s-and-p-500-companies/main/data/constituents.csv'
        headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'}
        response = requests.get(url, headers=headers)
        response.raise_for_status()
        df_tickers = pd.read_csv(io.StringIO(response.text))
        df_tickers['Symbol'] = df_tickers['Symbol'].str.replace('.', '-', regex=False)
        print(f"S&P 500 티커 {len(df_tickers)}개 로드 완료.")
        return df_tickers[['Symbol', 'GICS Sector']].to_dict('records')
    except Exception as e:
        print(f"티커 로드 오류: {e}")
        return [
            {'Symbol': 'AAPL', 'GICS Sector': 'Information Technology'},
            {'Symbol': 'MSFT', 'GICS Sector': 'Information Technology'},
            {'Symbol': 'AMZN', 'GICS Sector': 'Consumer Discretionary'},
            {'Symbol': 'GOOGL', 'GICS Sector': 'Communication Services'},
            {'Symbol': 'META', 'GICS Sector': 'Communication Services'},
            {'Symbol': 'TSLA', 'GICS Sector': 'Consumer Discretionary'},
            {'Symbol': 'NVDA', 'GICS Sector': 'Information Technology'},
            {'Symbol': 'JPM', 'GICS Sector': 'Financials'},
            {'Symbol': 'HD', 'GICS Sector': 'Consumer Discretionary'},
            {'Symbol': 'PFE', 'GICS Sector': 'Health Care'},
            {'Symbol': 'CVX', 'GICS Sector': 'Energy'},
            {'Symbol': 'XOM', 'GICS Sector': 'Energy'}
        ]

def get_top_100_by_market_cap(tickers):
    market_caps = []
    for item in tickers:
        symbol = item['Symbol']
        try:
            ticker = yf.Ticker(symbol)
            market_cap = ticker.info.get('marketCap', 0) / 1e8
            market_caps.append((symbol, market_cap, item['GICS Sector']))
            time.sleep(0.1)
        except Exception as e:
            print(f"{symbol} 시총 데이터 오류: {e}")
    market_caps = sorted(market_caps, key=lambda x: x[1], reverse=True)[:100]
    return market_caps

def get_latest_trading_day():
    kst = ZoneInfo("Asia/Seoul")
    now_kst = datetime.now(kst)
    print(f"KST 현재 시간: {now_kst}")

    # 기본 후보: 하루 전
    candidate_date = now_kst - timedelta(days=1)

    # yfinance로 최신 거래일 확인
    end_date_for_yf = (now_kst + timedelta(days=1)).strftime('%Y-%m-%d')  # 다음날 포함
    start_date_check = (now_kst - timedelta(days=7)).strftime('%Y-%m-%d')

    try:
        data = yf.download('AAPL', start=start_date_check, end=end_date_for_yf, progress=False)
        if data.empty:
            print("yfinance 데이터 없음, 하루 전으로 조정")
            candidate_date -= timedelta(days=1)
            while candidate_date.weekday() >= 5:  # 주말 체크
                candidate_date -= timedelta(days=1)
        else:
            last_trading_date = data.index[-1].strftime('%Y-%m-%d')
            print(f"yfinance 마지막 거래일: {last_trading_date}")
            expected_date = (now_kst - timedelta(days=1)).strftime('%Y-%m-%d')
            if last_trading_date != expected_date:
                print(f"최신 거래일({last_trading_date}) != 예상({expected_date}), 하루 전으로 조정")
                candidate_date = now_kst - timedelta(days=1)
                while candidate_date.weekday() >= 5 or candidate_date.strftime('%Y-%m-%d') > last_trading_date:
                    candidate_date -= timedelta(days=1)

    except Exception as e:
        print(f"yfinance 오류: {e}, 하루 전으로 대체")
        candidate_date = now_kst - timedelta(days=1)
        while candidate_date.weekday() >= 5:
            candidate_date -= timedelta(days=1)

    target_date = candidate_date.strftime('%Y-%m-%d')
    end_date_for_yf = (candidate_date + timedelta(days=1)).strftime('%Y-%m-%d')
    print(f"대상 거래일 (T): {target_date}")
    print(f"yfinance end (포함 보장): {end_date_for_yf}")
    return target_date, end_date_for_yf

# 티커 및 섹터 리스트
sp500 = get_sp500_tickers()
total_tickers = len(sp500)

# 날짜 설정
target_date, end_date_yf = get_latest_trading_day()
print(f"분석 기준일 (target_date): {target_date}")
start_date = (datetime.strptime(target_date, '%Y-%m-%d') - timedelta(days=100)).strftime('%Y-%m-%d')
print(f"yfinance end_date: {end_date_yf}")
print(f"분석 기간: {start_date} ~ {end_date_yf} (포함 {target_date})")

# 결과 리스트 초기화
정배열 = []
역배열 = []
신규_정배열 = []
정배열_이탈 = []
top_100_정배열 = []
top_100_역배열 = []
top_100_신규_정배열 = []
top_100_정배열_이탈 = []
sector_data = {sector: {'정배열': [], '역배열': [], '신규_정배열': [], '정배열_이탈': [], 'total': 0}
               for sector in set(item['GICS Sector'] for item in sp500)}

for item in sp500:
    sector_data[item['GICS Sector']]['total'] += 1

top_100 = get_top_100_by_market_cap(sp500)
top_100_tickers = [x[0] for x in top_100]

for item in sp500:
    symbol = item['Symbol']
    sector = item['GICS Sector']
    try:
        data = yf.download(symbol, start=start_date, end=end_date_yf, progress=False, auto_adjust=True)
        if data.empty or 'Close' not in data.columns:
            print(f"{symbol} 데이터 없음")
            continue
        data = data[['Close']].copy().sort_index(ascending=True).dropna()

        if len(data) < 50:
            print(f"{symbol}: 데이터 부족 (len={len(data)})")
            continue

        # 최신 데이터가 target_date인지 확인
        if data.index[-1].strftime('%Y-%m-%d') != target_date:
            print(f"{symbol}: 마지막 데이터 {data.index[-1].strftime('%Y-%m-%d')}가 {target_date} 아님, 스킵")
            continue

        # EMA 계산
        data['10ema'] = data['Close'].ewm(span=10, adjust=False).mean()
        data['20ema'] = data['Close'].ewm(span=20, adjust=False).mean()
        data['50ema'] = data['Close'].ewm(span=50, adjust=False).mean()

        # 정배열 및 역배열
        data['정배열'] = (data['10ema'] > data['20ema']) & (data['20ema'] > data['50ema'])
        data['역배열'] = (data['10ema'] < data['20ema']) & (data['20ema'] < data['50ema'])

        # T일 정배열/역배열 체크
        if data['정배열'].iloc[-1]:
            정배열.append(symbol)
            if symbol in top_100_tickers:
                top_100_정배열.append(symbol)
            sector_data[sector]['정배열'].append(symbol)
        if data['역배열'].iloc[-1]:
            역배열.append(symbol)
            if symbol in top_100_tickers:
                top_100_역배열.append(symbol)
            sector_data[sector]['역배열'].append(symbol)

        # 신규 정배열 및 정배열 이탈
        if len(data) >= 2:
            prev_bullish = data['정배열'].shift(1).fillna(False).iloc[-1]  # T-1
            curr_bullish = data['정배열'].iloc[-1]  # T

            close_t = float(data['Close'].iloc[-1])  # T일 종가
            close_t_minus_1 = float(data['Close'].iloc[-2])  # T-1 종가
            ema20_t = float(data['20ema'].iloc[-1])  # T일 20EMA
            price_change = ((close_t - close_t_minus_1) / close_t_minus_1) * 100

            # 신규 정배열: T-1 정배열 X → T 정배열 O
            if not prev_bullish and curr_bullish:
                신규_정배열.append((symbol, price_change))
                if symbol in top_100_tickers:
                    top_100_신규_정배열.append((symbol, price_change))
                sector_data[sector]['신규_정배열'].append((symbol, price_change))

            # 정배열 이탈: T 정배열 유지 + 주가 하락 + 20EMA 터치/하회
            if curr_bullish and close_t < close_t_minus_1 and close_t <= ema20_t:
                정배열_이탈.append((symbol, price_change))
                if symbol in top_100_tickers:
                    top_100_정배열_이탈.append((symbol, price_change))
                sector_data[sector]['정배열_이탈'].append((symbol, price_change))
        else:
            print(f"{symbol}: 데이터 포인트 부족 (len={len(data)})")

        time.sleep(0.5)

    except Exception as e:
        print(f"{symbol} 처리 오류: {e}")
        continue

# 정렬
신규_정배열 = sorted(신규_정배열, key=lambda x: x[1], reverse=True)
정배열_이탈 = sorted(정배열_이탈, key=lambda x: x[1])
top_100_신규_정배열 = sorted(top_100_신규_정배열, key=lambda x: x[1], reverse=True)
top_100_정배열_이탈 = sorted(top_100_정배열_이탈, key=lambda x: x[1])

for sector in sector_data:
    sector_data[sector]['신규_정배열'] = sorted(sector_data[sector]['신규_정배열'], key=lambda x: x[1], reverse=True)
    sector_data[sector]['정배열_이탈'] = sorted(sector_data[sector]['정배열_이탈'], key=lambda x: x[1])

# 비율 계산
정배열_비율 = len(정배열) / total_tickers * 100 if total_tickers > 0 else 0
정배열_역배열_비율 = len(정배열) / len(역배열) if len(역배열) > 0 else float('inf')
신규정배열_이탈_비율 = len(신규_정배열) / len(정배열_이탈) if len(정배열_이탈) > 0 else float('inf')
top_100_정배열_비율 = len(top_100_정배열) / len(top_100_tickers) * 100 if top_100_tickers else 0
top_100_정배열_역배열_비율 = len(top_100_정배열) / len(top_100_역배열) if len(top_100_역배열) > 0 else float('inf')
top_100_신규정배열_이탈_비율 = len(top_100_신규_정배열) / len(top_100_정배열_이탈) if len(top_100_정배열_이탈) > 0 else float('inf')

sector_stats = {}
for sector in sector_data:
    total = sector_data[sector]['total']
    sector_stats[sector] = {
        '정배열_비율': len(sector_data[sector]['정배열']) / total * 100 if total > 0 else 0,
        '신규정배열_이탈_비율': len(sector_data[sector]['신규_정배열']) / len(sector_data[sector]['정배열_이탈']) if len(sector_data[sector]['정배열_이탈']) > 0 else float('inf')
    }

sorted_sectors = sorted(sector_stats.items(), key=lambda x: x[1]['정배열_비율'], reverse=True)
top_3_sectors = sorted_sectors[:3]
bottom_3_sectors = sorted_sectors[-3:] if len(sorted_sectors) >= 3 else sorted_sectors

# 메시지 구성
message = f"📊 S&P 500 EMA(10,20,50) 요약 ({target_date}):\n"
message += f"- 정배열: {len(정배열)}개 ({정배열_비율:.2f}%)\n"
message += f"- 신규 정배열: {len(신규_정배열)}개\n"
message += f"- 정배열 이탈: {len(정배열_이탈)}개\n"
message += f"- 신규 정배열/이탈 비율: {신규정배열_이탈_비율:.2f}\n"
message += f"\n시총 상위 100종목:\n"
message += f"- 정배열: {len(top_100_정배열)}개 ({top_100_정배열_비율:.2f}%)\n"
message += f"- 신규 정배열/이탈 비율: {top_100_신규정배열_이탈_비율:.2f}\n"

message += f"\n섹터별 정배열 비율 (상위 3개 및 하위 3개):\n상위 3개:\n"
for sector, stats in top_3_sectors:
    message += f"- {sector}: {stats['정배열_비율']:.2f}% (신규/이탈: {stats['신규정배열_이탈_비율']:.2f})\n"
message += f"하위 3개:\n"
for sector, stats in bottom_3_sectors:
    message += f"- {sector}: {stats['정배열_비율']:.2f}% (신규/이탈: {stats['신규정배열_이탈_비율']:.2f})\n"

message += f"\n📊 전체 상세 결과 ({target_date} vs 전일 변화율):\n"
message += f"신규 정배열 ({len(신규_정배열)}개, 높은 순):\n"
for symbol, change in 신규_정배열[:10]:
    message += f"  - {symbol}: {change:.2f}%\n"
message += f"정배열 이탈 ({len(정배열_이탈)}개, 낮은 순):\n"
for symbol, change in 정배열_이탈[:10]:
    message += f"  - {symbol}: {change:.2f}%\n"

message += f"\n📊 시총 상위 100 신규 정배열:\n"
for symbol, change in top_100_신규_정배열:
    message += f"  - {symbol}: {change:.2f}%\n"
message += f"시총 상위 100 정배열 이탈:\n"
for symbol, change in top_100_정배열_이탈:
    message += f"  - {symbol}: {change:.2f}%\n"

message += f"\n📊 섹터별 신규/이탈 (주요 섹터):\n"
for sector in ['Information Technology', 'Financials', 'Health Care', 'Consumer Discretionary']:
    if sector in sector_data:
        message += f"{sector} (정배열 {sector_stats[sector]['정배열_비율']:.1f}%):\n"
        new_bull = sector_data[sector]['신규_정배열']
        exits = sector_data[sector]['정배열_이탈']
        if new_bull:
            message += f"  신규: {new_bull[0][0]} {new_bull[0][1]:.2f}%\n"
        if exits:
            message += f"  이탈: {exits[0][0]} {exits[0][1]:.2f}%\n"

send_telegram_message(message)
print(message)